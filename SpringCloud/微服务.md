# `SpringCloud-Netflix`

#### 概述

`SpringCloud-Netflix`体系

- ​       **服务发现——Netflix Eureka**

- ​       **服务调用——Netflix Feign**

- ​       **熔断器——Netflix Hystrix**

- ​       **服务网关——Netflix Zuul**

- ​       **分布式配置——Spring Cloud Config**

- ​       **消息总线——Spring Cloud Bus**

父项目版本锁定

```xml

    <dependencyManagement>
        <dependencies>
            <!-- spring boot 2.2.2 -->
            <dependency>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-dependencies</artifactId>
                <version>2.2.5.RELEASE</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
            <!-- spring cloud Hoxton.SR1 -->
            <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-dependencies</artifactId>
                <version>Hoxton.SR1</version>
                <type>pom</type>
                <scope>import</scope>
            </dependency>
        </dependencies>
    </dependencyManagement>
```

  

### 注册中心

#### Eureka

###### 服务端

` learn-netflix-eureka`

1.导入

```xml
         <dependency>
                <groupId>org.springframework.cloud</groupId>
                <artifactId>spring-cloud-starter-netflix-eureka-server</artifactId>
            </dependency>
```

2.开启

```java
/**
 * 注册中心
 *  @EnableEurekaServer 开启注册中心即可
 *
 */
@EnableEurekaServer
@SpringBootApplication
public class LearnNetflixEurekaApplication {
    public static void main(String[] args) {
        SpringApplication.run(LearnNetflixEurekaApplication.class,args);
    }
}
```

3.配置

```yaml
server:
  port: 1001
spring:
  application:
    # 服务名称
    name: Eureka-Regiser
# 注册中心配置   
eureka:
  instance:
    # 主机名
    hostname: 127.0.0.1 
   # 注册中心单机配置 
  client:
    # 默认下注册中心也是一个客户端，会向注册中心（自己）发起注册因此要禁止
    register-with-eureka: false
    # 指示此客户端是否应从eureka服务器获取eureka注册表信息。
    # 因其本身就是注册服务器，也要禁止
    fetch-registry: false
    service-url:
      # 配置注册中心的注册地址 127.0.0.1:1001/eureka，即声明自身地址就可
      defaultZone: "http://${eureka.instance.hostname}:${server.port}/eureka/"

```

```yaml

eureka:
  instance:
    # 主机名
    hostname: 127.0.0.1 
   # 注册中心单机配置 
  client: 
    register-with-eureka: false     #false表示不向注册中心注册自己。
    fetch-registry: true    
    service-url: 
      #设置与Eureka Server交互的地址查询服务和注册服务都需要依赖这个地址（单机）。
      defaultZone: http://ip:端口/eureka/,http://ip:端口/eureka/
```

###### 客户端

所谓客户端即除注册中心之外的其他微服务都需要向注册中心注册

1.导入

```xml
      <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
```

2.开启

```java
/**
 * 客户端
 *  @EnableDiscoveryClient 和 @EnableEurekaClient 都可以发起注册
 *  @EnableEurekaClient是Eureka自带的原生注解，只能用于Eureka的注册
 *  @EnableDiscoveryClient是Spring体系的一个抽象，不仅可以用于Eureka还可以用于
 */
@EnableEurekaClient
@SpringBootApplication
public class LearnNetflixEurekaClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(LearnNetflixEurekaClientApplication.class,args);
    }
}
```

3.配置

```yaml
server:
  port: 8001
spring:
  application:
    # 服务名称
    name: Eureka-Client
eureka:
  client:
    service-url:
      # 注册中心的地址
      defaultZone: "http://127.0.0.1:1001/eureka/"
```

#### Consul

Consul可以替换Eureka，Consul注册中心需要从官网下载安装

[下载地址]: https://www.consul.io/

客户端

1.导入

```xml
      <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-consul-discovery</artifactId>
        </dependency>
```

2.开启

```java
@EnableDiscoveryClient
@SpringBootApplication
public class LearnSpringCloudConsulClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(LearnSpringCloudConsulClientApplication.class,args);
    }
}
```

3.配置

```yaml
server:
  port: 8051
spring:
  application:
    # 服务名称
    name: Consul-Client
  cloud:
    consul:
    # consul服务器地址
      discovery:
        hostname: 127.0.0.1
        port: 8500
```

### 服务调用

#### REST

所谓服务调用，即微服务与微服务之间服务调用，SpringCloud提供了基于REST模板的服务调用

##### 服务提供方

`learn-netflix-eureka-client`

服务提供方会向eureka注册

```java
@RestController
public class ServiceController {

    /**
     * discoveryClient 从注册中心获取服务信息的接口
     **/
    @Autowired
    DiscoveryClient discoveryClient;

    @GetMapping("info")
    public Map info(){
        Map<String,Object> map=new HashMap<>();
        map.put("services",discoveryClient.getServices());
        map.put("description", discoveryClient.description());
        return map;
    }

}
```

##### 服务调用方

`learn-netflix-eureka-consumer`

服务调用方和服务提供方都是eureka的客户端

```java
@RestController
public class ServiceController {
    
    /**
     * 请求负载
     **/
    @Autowired
    LoadBalancerClient loadBalancerClient;

    /**
     *请求模板
     **/
    @Autowired
    RestTemplate restTemplate;
    @GetMapping("/info")
    public Map info(){
        // 通过服务名获取一个可用的服务地址
        // 虽然实现了请求的负载但需要手动拼接请求的url
        ServiceInstance serviceInstance=loadBalancerClient.choose("eureka-client");
        String url="http://"+serviceInstance.getHost()+":"+serviceInstance.getPort()+"/info";
        System.out.println(url);
        // 发起服务调用
       return restTemplate.getForObject(url,Map.class);
    }

}
```

#### Ribbon

`learn-netflix-eureka-consumer-ribbon`

ribbon提供了基于REST服务调用的进一步封装

```xml
       <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
        </dependency>
```

```java
@EnableDiscoveryClient
@SpringBootApplication
public class LearnNetflixEurekaConsumerRibbonApplication {
    public static void main(String[] args) {
        SpringApplication.run(LearnNetflixEurekaConsumerRibbonApplication.class,args);
    }

    /**
     * 用于服务间的调用
     *  负载均衡
     * @return
     */
    @LoadBalanced
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
```

```java

@RestController
public class ServiceController {

    /**
     * Ribbon 提供了基于服务名称进行REST服务间调用
     */
    @Autowired
    RestTemplate restTemplate;
    @GetMapping("/info")
    public Map info(){
        // 发起服务调用 直接使用目标微服务的名称进行访问
        return restTemplate.getForObject("http://Eureka-Client/info",Map.class);
    }

}
```

#### Feign

Feign提供了声明式基于注解的服务间调用

1.导入

```xml
    <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
```

2.开启

```java
/**
 * @EnableFeignClients
 * 启动 Feign的注解扫描
 * 只在服务调用方开启即可
 */
@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
public class LearnNetflixEurekaConsumerFeignApplication {
    public static void main(String[] args) {
        SpringApplication.run(LearnNetflixEurekaConsumerFeignApplication.class,args);
    }

    /**
     * 用于服务间的调用
     *  负载均衡
     * @return
     */
    @LoadBalanced
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
```

3.使用

```java
/***controller层**/
@RestController
public class ServiceController {
    @Autowired
    ServiceApi serviceApi;
    @GetMapping("/info")
    public Map info(){
        // 发起服务调用
        return serviceApi.info();
    }
}
/**
 * 接口层 
 * 只需设置服务调用方即可
 */
@FeignClient("Eureka-Client")
public interface ServiceApi {
    @GetMapping("info")
    Map info();
}

```

### 服务治理

在基于REST请求的调用时实现了远程服务的调用和请求负载，但在复杂系统中，微服务之间容易形成调用链，其中一种微服务的崩溃或请求延迟都会拖累整个系统，有时也需要主动关闭某些服务

#### Ribbon+Hystrix

`learn-netflix-eureka-consumer-ribbon-hystrix`

1.导入

```xml
 <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-ribbon</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>
```

2.开启

```java
/**目前为止没有什么不同**/
@EnableCircuitBreaker
@EnableDiscoveryClient
@SpringBootApplication
public class LearnNetflixEurekaConsumerHystrixApplication {
    public static void main(String[] args) {
        SpringApplication.run(LearnNetflixEurekaConsumerHystrixApplication.class,args);
    }

    /**
     * 用于服务间的调用
     *  负载均衡
     * @return
     */
    @LoadBalanced
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
```

3.调用

```java
@RestController
public class ServiceController {

    @Autowired
    InfoService  infoService;

    @GetMapping("/info")
    public Map info(){
        // 发起服务调用
        return infoService.info();
    }
    @GetMapping("/info2")
    public Map info2(){
        // 发起服务调用
        return infoService.info2();
    }
}


@Service
public class InfoService {
    /**
     * Ribbon 提供了基于服务名称进行REST服务间调用
     */
    @Autowired
    RestTemplate restTemplate;

    /**
     * @HystrixCommand(fallbackMethod = "fallback")
     *  配置断路器，在目标服务掉线时执行本地方法
     *
     */
    @HystrixCommand(fallbackMethod = "fallback")
    public Map info() {
        return  restTemplate.getForObject("http://Eureka-Client/info",Map .class);
    }

    /**
     *  @HystrixCommand应用于线程资源级别，而不是服务级别
     *   info() 会因为延迟走本地方法
     *   info2() 则不会
     *   虽然两个方法对应的是同一个服务，但对应不同的资源
     * @return
     */
    @HystrixCommand(fallbackMethod = "fallback")
    public Map info2() {
        return  restTemplate.getForObject("http://Eureka-Client/info2",Map .class);
    }

    /**
     *请求超时或请求的服务不在线时则返回本地方法，预防请求堆积
     **/
    public Map fallback(){
        Map<String,String>map=new HashMap<>();
        map.put("status","ERR");
        map.put("msg","对应服务不在线");
        return map;
    }

}
```

#### Feign+Hystrix

`learn-netflix-eureka-consumer-feign-hystrix`

 1.导入

```xml
 <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-openfeign</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>
        </dependency>
        <!--熔断器的监控-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
```

2.开启

```java
/**
 * @EnableFeignClients
 * 启动 Feign的注解扫描
 * 只在服务调用方开启即可
 *
 * @EnableHystrix
 * 必须则yml中开启feign的熔断
 * 熔断降级
 */
@EnableHystrix
@EnableFeignClients
@EnableDiscoveryClient
@SpringBootApplication
public class LearnNetflixEurekaConsumerFeignHystrixApplication {
    public static void main(String[] args) {
        SpringApplication.run(LearnNetflixEurekaConsumerFeignHystrixApplication.class,args);
    }

    /**
     * 用于服务间的调用
     *  负载均衡
     * @return
     */
    @LoadBalanced
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
```

3.配置

```yaml
server:
  port: 8009
spring:
  application:
    # 服务名称
    name: Eureka-Consumer-Feign

eureka:
  client:
    service-url:
      # 注册中心的地址
      defaultZone: "http://127.0.0.1:1001/eureka/"

# 必须开启，默认是不开启的
feign:
  hystrix:
    enabled: true

management:
  endpoints:
    web:
      exposure:
        include: '*'

```

4.使用

```java
@RestController
public class ServiceController {

    @Autowired
    ServiceApi serviceApi;

    @GetMapping("/info")
    public Map info(){
        // 发起服务调用
        return serviceApi.info();
    }
    @GetMapping("/info2")
    public Map info2(){
        // 发起服务调用
        return serviceApi.info2();
    }
}

/**
 * 接口
 * 指定回调类
 */
@FeignClient(name = "Eureka-Client",fallback = ServiceApiFallback.class)
public interface ServiceApi {

    @GetMapping("info")
    Map info();

    @GetMapping("info2")
    Map info2();
}
/**
 *本地实现在请求超时或微服务不在线时触发
 **/
@Service
public class ServiceApiFallback  implements ServiceApi{
 static Map<String,String>map=new HashMap<>();
  static {
      map.put("status","服务不在线");
  }
    @Override
    public Map info() {
        return map;
    }
    @Override
    public Map info2() {
        return map;
    }
}
```

### 配置中心

SpringBoot 配置文件 `application.yml`和`bootstrap.yml`,bootstrap有限期大于application配置

所谓配置中心，即在微服务下，服务增多，配置文件也相应增多，为了方便管理需要把可变的配置文件单独提取出来，使用bootstrap来满足服务启动的基本固定配置，而可变配置通过远程加载application.yml

#### 配置中心

`learn-spring-cloud-config-server`

1.导入

```xml
  <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-config-server</artifactId>
        </dependency>
        <!--注册到注册中心-->
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
```

2.启动

```java
/**
 * @EnableConfigServer
 *  开启配置中心
 *   配置中心负责从本地文件或git仓库中读取配置
 *   配置中心负责其他微服务的配置拉取请求
 *
 *
 *   在仓库中配置文件的命名规范为
 *     { 应用名 } - { 环境名 }.yml
 *     { 应用名 } - { 环境名 }.properties
 *     假设微服务的Eureka-Client则配置文件名
 *     Eureka-Client.yml 相当于 Eureka-Client-default.yml 即默认配置
 *     Eureka-Client-dev.yml 即生产环境下的配置
 *
 *  请求客户端请求
 *    http://ip:端口/config-client/dev/master 可以查询分支
 *  请求具体的文件
 *   http://ip:端口/目标文件路径
 *   目标文件路径拼接规则
 *   application对应的微服务名
 *   profile环境 default还是生产环境
 *   label 在git下，git版本
 *    1.   /{application}/{profile}[/{label}]         / { 应用名 } / { 环境名 }  获取分支信息
 *    2.  /{application}-{profile}.yml                / { 应用名 } - { 环境名 }.yml
 *    3.  /{label}/{application}-{profile}.yml         / { 应用名 } - { 环境名 }.yml
 *    4.  /{application}-{profile}.properties          / { 应用名 } - { 环境名 }.properties
 *    5. /{label}/{application}-{profile}.properties   / { 分支名 } / { 应用名 } - { 环境名 }.properties
 *
 */
@EnableDiscoveryClient
@EnableConfigServer
@SpringBootApplication
public class LearnCloudConfigServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(LearnCloudConfigServerApplication.class,args);
    }
}
```

3.配置

```yaml
server:
  port: 1002
spring:
  application:
    name: Config-Server
  # 配置中心 git仓库
  cloud:
    config:
      server:
        git:
          uri: git@gitee.com:lysmayun/springcloud-config.git
eureka:
  client:
    service-url:
      # 注册中心的地址
      defaultZone: "http://127.0.0.1:1001/eureka/"
```

#### 调用与刷新

`learn-spring-cloud-config-client`

1.导入

```xml
   <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-config</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.cloud</groupId>
            <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
        </dependency>
       <!--监控+refresh配置-->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
    </dependencies>
```

2.启动

```java
@EnableDiscoveryClient
@SpringBootApplication
public class LearnSpringCloudConfigClientApplication {
    public static void main(String[] args) {
        SpringApplication.run(LearnSpringCloudConfigClientApplication.class,args);
    }
}
```

3.配置**bootstrap.yml**

```yaml
# bootstrap.yml 优先级高于application.yml
spring:
  application:
    name: Config-Client
  cloud:
    config:
      # 注册中心
      discovery:
        enabled: true
        service-id: Config-Server
      # 单中心注册中心地址
      #uri: http://127.0.0.1:1002/
      # 环境
      profile: default
      #　版本号
      label: master


server:
  port: 8007

eureka:
  client:
    service-url:
      # 注册中心的地址
      defaultZone: "http://127.0.0.1:1001/eureka/"

# 通过actuator的监控功能refresh 来实现远程配置的动态更新
# 此处不配置不生效
# 当远程配置发生改变时可以通过
# POST http://127.0.0.1:8007/refresh 来动态刷新配置
management:
  server:
    port: 8007
  endpoints:
    web:
      base-path: /
      exposure:
        include: refresh,health,info
```

### 服务网关

网关： 是一个网络整体系统中的前置门户入口。请求首先通过网关，进行路径的路由，定位到具体的服务节点上。

　　Zuul是一个微服务网关，首先是一个微服务。也是会在Eureka注册中心中进行服务的注册和发现。也是一个网关，请求应该通过Zuul来进行路由。Zuul网关不是必要的。是推荐使用的。使用Zuul，一般在微服务数量较多的时候推荐使用，对服务的管理有严格要求的时候推荐使用，当微服务权限要求严格的时候推荐使用。

- 统一入口：未全部为服务提供一个唯一的入口，网关起到外部和内部隔离的作用，保障了后台服务的安全性。
- 鉴权校验：识别每个请求的权限，拒绝不符合要求的请求。
- 动态路由：动态的将请求路由到不同的后端集群中。
- 减少客户端与服务端的耦合：服务可以独立发展，通过网关层来做映射。

`learn-netflix-eureka-zuul`

1.导入

```xml
       <dependency>
           <groupId>org.springframework.cloud</groupId>
           <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>
       </dependency>
       <dependency>
           <groupId>org.springframework.cloud</groupId>
           <artifactId>spring-cloud-starter-netflix-zuul</artifactId>
       </dependency>
```

2.开启

```java
@EnableZuulProxy
@SpringCloudApplication
public class LearnNetflixEurekaZuulApplication {
    public static void main(String[] args) {
        SpringApplication.run(LearnNetflixEurekaZuulApplication.class,args);
    }
}
```

3.配置

```yaml
server:
  port: 1003
eureka:
  client:
    service-url:
      defaultZone: "http://127.0.0.1:1001/eureka/"
spring:
  application:
    name: Netflix-Zuul

# 路由配置，在不配置的情况下默认为
#最终请求路径　http://127.0.0.1:8001/info　 服务名 Eureka-Client
#       则默认请求下为 http://127.0.0.1:1003/eureka-client/info
#       通过以下配置   http://127.0.0.1:1003/v1/info
zuul:
  routes:
     Eureka-Client: /v1/**
     eureka-consumer-feign: /v2/**

# zuul服务发起调用 ——》A微服务（feign+hystrix）——》B微服务
# 若A调用B时超时，理论上会返回A的本地调用
# 但zuul本身也有超时配置，因此还为等到A的超时触发ZULL则已经超时
# feign是基于ribbon的
ribbon:
  ReadTimeout: 10000
  ConnectTimeout: 10000
```

#### 网关熔断

```java
@Component
public class DefaultFallbackProvide implements FallbackProvider {
    private final static  String fallback = "服务异常,稍后重试";

    /**
     * 此处返回需要熔断的微服务名称
     *  return null 或者 return "*"
     *  则代表所有微服务请求超时时都会走此处
     * @return
     */
    @Override
    public String getRoute() {
        return "*";
    }
    
    @Override
    public ClientHttpResponse fallbackResponse(String route, Throwable cause) {
     return new ClientHttpResponse() {
            @Override
            public HttpStatus getStatusCode() throws IOException {
                return HttpStatus.BAD_GATEWAY;
            }
            @Override
            public int getRawStatusCode() throws IOException {
                return HttpStatus.BAD_REQUEST.value();
            }

            @Override
            public String getStatusText() throws IOException {
                return HttpStatus.BAD_REQUEST.getReasonPhrase();
            }

            @Override
            public void close() {

            }

            @Override
            public InputStream getBody() throws IOException {
                return new ByteArrayInputStream((route+fallback).getBytes());
            }

            @Override
            public HttpHeaders getHeaders() {
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                return headers;
            }
        };

    }
}
```

#### 网关过滤

在网关层的过滤一般用来做用户和权限认证

```java
@Component
public class DefaultAccessFilter extends ZuulFilter {
    /**
     * 过滤器的类型，它决定过滤器在请求的哪个生命周期中执行。
     * 这里定义为pre，代表会在请求被路由之前执行。
     * @return
     */
    @Override
    public String filterType() {
        return "pre";
    }

    /**
     * 过滤器的执行顺序。当请求在一个阶段中存在多个过滤器时，
     * 需要根据该方法返回的值来依次执行。
     * @return
     */
    @Override
    public int filterOrder() {
        return 0;
    }

    /**
     * 判断该过滤器是否需要被执行。这里我们直接返回了true，
     * 因此该过滤器对所有请求都会生效。
     * 实际运用中我们可以利用该函数来指定过滤器的有效范围。
     * @return
     */
    @Override
    public boolean shouldFilter() {
        return true;
    }

    /**
     * 过滤器的具体逻辑。
     *  这里我们通过ctx.setSendZuulResponse(false)令zuul过滤该请求，不对其进行路由，
     *  然后通过ctx.setResponseStatusCode(401)设置了其返回的错误码，
     *  当然我们也可以进一步优化我们的返回，
     *  比如，通过ctx.setResponseBody(body)对返回body内容进行编辑等。
     * @return
     * @throws ZuulException
     */
    @Override
    public Object run() throws ZuulException {
        RequestContext ctx = RequestContext.getCurrentContext();
        HttpServletRequest request = ctx.getRequest();

        System.out.println(request.getMethod()+"  "+request.getRequestURL().toString());

        Object accessToken = request.getParameter("accessToken");
        if(accessToken == null) {
            System.out.println("access token is empty");
            ctx.setSendZuulResponse(false);
            ctx.setResponseStatusCode(401);
            ctx.setResponseBody("access denied ");
            return null;
        }
        return null;
    }
}
```

### 消息驱动



微服务之间的服务调用是通过REST 客户端—服务器**同步模式实现的**，很多时候服务与服务之间需要异步结构来提高性能，即通过中间件 发布订阅者模式来实现，通过消息机制来实现服务间的调用